1.前端监控实现原理
监听浏览器中的错误事件
window.addEventListener('error', this.handleError.bind(this));  
window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));  
利用performance采集性能数据

页面加载时间
首次内容渲染时间（First Contentful Paint, FCP）
首次有效渲染时间（First Meaningful Paint, FMP）
可交互时间（Time to Interactive, TTI）
资源加载时间
JavaScript执行时间
PV（Page View）：页面的浏览数量，每打开页面一次就会统计一次。
UV（User View）：不同用户访问的次数，在PV的基础上根据User信息的不同做了去重操作。
用户在每个页面停留的时间：即从用户打开该页面到用户离开该页面的时间差，用于表示该页面对用户的留存程度。
用户的来处：即从什么入口或什么渠道来到了当前页面，通常会在URL中添加查询参数来做区分统计。
用户的页面操作行为：即用户在该页面点击了哪些按钮，或者从什么链接去到了某些页面等，用于分析用户的去向。


网络协议
OSI（Open Systems Interconnection，开放系统互连）模型是一个开放性的通信系统互连参考模型，它定义了网络通信的七层结构。这七层从上到下分别是：
应用层：这是网络协议的最高层，直接为用户提供应用服务。它定义了应用程序之间的通信服务，如HTTP、FTP、SMTP等协议都工作在这一层。
表示层：这一层的主要功能是定义数据格式及加密，确保数据在传输过程中的正确性和安全性。
会话层：负责在网络中的两个节点之间建立、管理和终止会话。
传输层：提供端到端的通信服务，确保数据包的可靠传输。常见的传输层协议有TCP和UDP。
网络层：负责数据包的路由选择，即选择最佳路径将数据包从源节点传输到目的节点。IP协议是这一层的核心协议。
数据链路层：定义了在单个链路上如何传输数据，包括数据的封装、帧的同步、差错控制等功能。
物理层：负责物理信号的传输，包括信号的编码、解码、调制、解调等功能。物理层常用多个规范完成对所有细节的定义，如Rj45、802.3等。

在网络通信中，特别是在使用TCP（传输控制协议）进行数据传输时，为了确保数据的可靠传输，TCP采用了三次握手（Three-way Handshake）来建立连接，以及四次挥手（Four-way Handshake）来断开连接。这两种机制都是TCP协议的核心部分，用于管理TCP连接的建立和终止。

三次握手（Three-way Handshake）
三次握手是TCP建立连接的过程，它确保了通信双方都能够接收和发送数据。具体步骤如下：
SYN请求：客户端向服务器发送一个SYN（同步序列编号）报文段。这个报文段不包含应用层数据，但它包含一个初始序列号（ISN，Initial Sequence Number），用于后续的TCP报文段中数据的顺序编号。此时，客户端进入SYN-SENT（同步已发送）状态。
SYN+ACK应答：服务器收到客户端的SYN报文段后，向客户端发送一个SYN+ACK（同步确认）报文段作为应答。这个报文段中包含了服务器的初始序列号，同时确认号为客户端的初始序列号加1，表示服务器已经收到了客户端的SYN报文段。此时，服务器进入SYN-RCVD（同步收到）状态。
ACK确认：客户端收到服务器的SYN+ACK报文段后，向服务器发送一个ACK（确认）报文段。这个报文段的确认号为服务器的初始序列号加1，表示客户端已经收到了服务器的SYN报文段。此时，连接建立，客户端和服务器都进入ESTABLISHED（已建立）状态。

三次握手（Three-way Handshake）在TCP协议中用于建立连接，并且设计为三次而不是两次，主要是因为这种机制能够解决一系列潜在的问题，确保通信双方都能够准备好发送和接收数据。以下是为什么三次握手不能简化为两次的主要原因：

确认双方的发送和接收能力：
第一次握手（SYN）：客户端发送SYN报文给服务器，表示客户端想要建立连接，并包含客户端的初始序列号。这证明了客户端的发送能力是正常的。
第二次握手（SYN+ACK）：服务器回应SYN+ACK报文，确认收到了客户端的SYN报文，并包含服务器的初始序列号。这既证明了服务器的接收能力（因为它接收到了客户端的SYN），也证明了服务器的发送能力（因为它发送了SYN+ACK）。
如果只有两次握手，那么服务器就无法确认客户端是否已经收到了自己的SYN+ACK报文。如果客户端没有收到SYN+ACK，但服务器却认为连接已经建立并开始发送数据，那么这些数据将会被客户端丢弃（因为客户端还未准备好接收），导致数据丢失。
防止失效的连接请求：
在网络中，由于网络延迟或路由问题，一个旧的连接请求（SYN报文）可能会在网络中滞留并最终到达服务器。如果没有三次握手，服务器可能会基于这个旧的SYN报文建立一个新的连接，导致数据被发送到错误的客户端或发生其他混乱。
三次握手中的第三次（ACK）确保了客户端已经收到了服务器的SYN+ACK，从而避免了与旧的、失效的SYN报文建立连接的风险。
同步双方的初始序列号：
三次握手还允许双方同步它们的初始序列号，这对于后续的数据传输至关重要。每个TCP报文段都包含一个序列号，用于标识该报文段中的数据的顺序。通过三次握手，双方都能知道对方的初始序列号，从而确保数据能够按照正确的顺序进行重组。
综上所述，三次握手是TCP协议中确保连接可靠性和数据完整性的重要机制。它不能简化为两次握手，因为这样做会引入数据丢失、连接混淆和其他潜在问题。

四次挥手（Four-way Handshake）
四次挥手是TCP断开连接的过程，它允许通信双方优雅地关闭连接。具体步骤如下：

FIN请求关闭：客户端（或服务器）想要关闭连接时，会发送一个FIN（结束）报文段给对方，表示自己没有数据要发送了。此时，发送FIN报文段的一方进入FIN-WAIT-1（结束等待1）状态。
ACK确认：接收到FIN报文段的另一方会发送一个ACK报文段作为应答，表示已经收到了对方的FIN报文段。此时，如果它是客户端，则进入CLOSE-WAIT（关闭等待）状态；如果它是服务器，则进入LAST-ACK（最后确认）状态。
FIN请求关闭：一段时间后，如果原先发送FIN报文段的一方收到了对方的所有数据，会再次发送一个FIN报文段给对方，表示自己已经准备好关闭连接了。此时，该方进入TIME-WAIT（时间等待）状态。
ACK确认：接收到第二个FIN报文段的另一方会发送一个ACK报文段作为应答，表示已经收到了对方的FIN报文段，随后双方进入CLOSED（已关闭）状态，连接断开。
注意，在TIME-WAIT状态期间，TCP连接会保持一段时间（通常是2MSL，即两倍的报文段最大生存时间），以确保所有在网络中传输的报文段都已经过期，从而避免新的连接因为旧的报文段而被错误地建立。

四次挥手（Four-way Handshake）在TCP协议中用于断开连接，并且它设计为四次而不是三次，主要是因为这种机制需要确保双方都能够安全、有序地关闭连接，并释放相关资源。以下是为什么四次挥手不能简化为三次的主要原因：

确保数据完整传输：
在TCP连接中，双方都可能还有数据需要发送给对方。当一方想要关闭连接时，它首先会发送一个FIN报文给对方，表示自己没有更多的数据要发送了。但是，对方可能还有数据需要发送回来。
如果只有三次挥手，那么发送FIN报文的一方在收到对方的ACK后就会立即关闭连接，而不等待对方可能还有的数据传输完成。这会导致数据丢失。
确保双方都已准备好关闭：
在四次挥手中，当一方发送FIN报文后，它会等待对方发送一个ACK报文作为响应。然后，当这方也完成了所有数据的发送后，它会再次发送一个FIN报文给对方，表示自己也已经准备好关闭连接。
对方在收到第二个FIN报文后，会发送一个ACK报文作为最终的确认，之后双方都会关闭连接。这种机制确保了双方都已经准备好关闭连接，没有任何一方还在等待数据传输。
处理半关闭状态：
TCP连接支持半关闭状态，即一方关闭了发送通道，但还可以接收数据；而另一方则可以继续发送数据。四次挥手机制允许连接进入这种半关闭状态，直到双方都准备好关闭连接。
如果只有三次挥手，那么一旦发送了FIN报文并收到了ACK，连接就会立即关闭，无法进入半关闭状态。
防止延迟的ACK导致的问题：
在某些情况下，ACK报文可能会因为网络延迟而稍微延迟到达。如果只有三次挥手，并且没有等待足够的时间来确保ACK已经发送，那么连接可能会过早地关闭。
四次挥手通过发送第二个FIN报文来提供一个额外的确认机会，从而减少了因延迟ACK而导致的问题。
综上所述，四次挥手是TCP协议中确保连接能够安全、有序地关闭的重要机制。它不能简化为三次挥手，因为这样做会引入数据丢失、连接状态不一致和其他潜在问题。


dns缓存
1. 浏览器缓存
描述：浏览器会缓存DNS解析结果，以加快后续访问同一网站的速度。浏览器缓存的DNS记录与DNS服务器的TTL（Time to Live，生存时间）无直接关系，而是由浏览器自己设定的缓存时间来决定。例如，Chrome浏览器的DNS缓存时间通常为1分钟。
2. 本地系统缓存
描述：操作系统也会缓存DNS解析结果。Windows系统的DNS缓存通常保存在C:\Windows\System32\drivers\etc\hosts文件中，但更多临时的缓存信息则存储在操作系统的内存中。这些缓存信息可以加速对同一域名的后续解析请求。
3. 路由器缓存
描述：在家庭或企业网络中，路由器也可能缓存DNS解析结果。这有助于减轻网络负担并提高访问速度。路由器缓存的DNS记录也会根据TTL值来更新。
4. 本地DNS服务器缓存
描述：本地DNS服务器（也称为递归DNS服务器）会缓存它解析过的DNS记录。当客户端（如计算机或手机）向本地DNS服务器发起DNS解析请求时，如果请求的域名已经存在于本地DNS服务器的缓存中，那么服务器将直接返回缓存中的结果，而无需再向其他DNS服务器发起查询。这可以显著提高DNS解析的速度和效率。
5. 权威DNS服务器缓存
描述：权威DNS服务器是负责解析特定域名的DNS服务器。这些服务器也会缓存DNS记录，但通常它们的缓存策略更加复杂，因为它们需要确保缓存的DNS记录是最新的，并且能够反映域名的当前状态。
总结
DNS缓存一般发生在浏览器、本地系统、路由器、本地DNS服务器以及权威DNS服务器等多个环节。这些缓存机制共同构成了DNS解析的缓存体系，旨在提高DNS解析的速度和效率，减轻网络负担，并提升用户体验。在日常使用中，用户通常不需要手动干预这些缓存机制，因为它们会自动根据TTL值或其他策略来更新缓存中的DNS记录。然而，在某些特殊情况下（如DNS缓存污染或域名DNS服务器地址变更），用户可能需要手动清除缓存以获取最新的DNS解析结果。

XSS（跨站脚本攻击）
定义：
XSS（Cross Site Scripting）是跨站脚本攻击，攻击者利用网站对用户输入的数据没有进行足够的过滤的漏洞，将恶意脚本注入到用户浏览的页面中，当其他用户浏览该页面时，嵌入其中的恶意脚本就会被执行，从而达到攻击的目的。

类型：
XSS攻击主要分为以下几种类型：
反射型XSS：通过URL的参数传递恶意脚本，当受害者点击这些链接时，恶意脚本就会在受害者的浏览器中执行。
存储型XSS：攻击者将恶意脚本注入到网站的数据库中，当其他用户访问这些包含恶意脚本的页面时，恶意脚本就会被执行。
DOM型XSS：基于DOM（文档对象模型）的漏洞，攻击者通过修改页面的DOM结构来执行恶意脚本。
防范措施：
对所有用户输入的数据进行严格的过滤和转义处理。
设置XSS过滤器，定制过滤策略。
使用HTTP Only Cookie，禁止JavaScript读取Cookie值。
对输出进行编码，避免输出未经过滤的内容。


XSS（跨站脚本攻击）概述
XSS（Cross-Site Scripting，跨站脚本攻击）是一种代码注入攻击，攻击者通过在网站中注入恶意脚本，使之在用户的浏览器中执行。根据攻击方式和脚本存储位置的不同，XSS攻击可以分为三种类型：反射型XSS、存储型XSS和DOM型XSS。

1. 反射型XSS
反射型XSS通常发生在攻击者通过URL参数注入恶意脚本，被服务器接收并反射回用户浏览器执行。这类攻击通常不会将恶意脚本存储在服务器上。

Demo（反射型XSS）:

假设有一个简单的网页，该网页显示用户通过URL传递的参数：

html
<!-- vulnerable.html -->  
<!DOCTYPE html>  
<html>  
<head>  
    <title>反射型XSS Demo</title>  
</head>  
<body>  
    <h1>Welcome, <?php echo $_GET['name']; ?>!</h1>  
</body>  
</html>
攻击者可以通过构造URL http://example.com/vulnerable.html?name=<script>alert('XSS');</script> 来触发XSS攻击。

2. 存储型XSS
存储型XSS与反射型XSS的不同之处在于，恶意脚本被永久存储在服务器上（例如，在数据库、消息论坛、评论系统等），每当受害者访问包含该脚本的页面时，恶意脚本就会被执行。

Demo（存储型XSS）（简化版，通常涉及后端数据库存储）:

html
<!-- comment.html -->  
<!DOCTYPE html>  
<html>  
<head>  
    <title>存储型XSS Demo</title>  
</head>  
<body>  
    <h1>Comments:</h1>  
    <?php  
        // 假设这是从数据库读取的评论  
        $comment = "<script>alert('XSS');</script> This is a comment.";  
        echo $comment;  
    ?>  
</body>  
</html>
在这个例子中，恶意脚本已经“存储”在了一个假设的数据库中，并且被直接嵌入到了页面中。

3. DOM型XSS
DOM型XSS与上述两种类型不同，它不直接依赖于服务器端的代码或数据，而是基于DOM（文档对象模型）的修改。攻击者通过修改页面上的DOM元素来执行脚本。

Demo（DOM型XSS）:

html
<!DOCTYPE html>  
<html>  
<head>  
    <title>DOM型XSS Demo</title>  
</head>  
<body>  
    <h1>DOM XSS Example</h1>  
    <script>  
        // 假设这是从URL参数中获取的  
        var userInput = location.search.substring(1);  
        document.body.innerHTML += '<p>Hello, ' + userInput + '!</p>';  
    </script>  
</body>  
</html>
攻击者可以通过构造URL http://example.com/domxss.html?name=<img%20src=x%20onerror=alert('XSS')> 来执行DOM型XSS攻击。

防范措施
对输入进行验证和清理：确保所有用户输入在存储或显示之前都被正确验证和清理。
使用HTTP头：设置合适的Content-Type和X-Content-Type-Options等HTTP头来防止MIME类型混淆攻击。
输出编码：对输出进行编码，确保HTML、JavaScript、CSS等代码不会被浏览器误解释为可执行代码。
使用内容安全策略（CSP）：CSP可以减少XSS攻击的风险，通过指定哪些外部资源可以加载到页面上。

CSRF（跨站请求伪造）
定义：
CSRF（Cross-Site Request Forgery）是跨站请求伪造，也被称为One Click Attack或者Session Riding，攻击者利用用户在已登录的Web应用程序上执行非本意的操作。
攻击原理：
用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A。
在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功。
用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B（内含恶意代码）。
网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A。
浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。
防范措施：
将Cookie设置为HttpOnly。
验证HTTP Referer字段，确保请求来自合法的来源。
在请求地址中添加Token并验证，确保请求的有效性。
在HTTP头中自定义属性并验证，增加额外的验证机制。


SSRF（服务端请求伪造）
定义：
SSRF（Server-Side Request Forgery）是服务端请求伪造，攻击者构造请求，由服务端发起请求的一种安全漏洞。它将一个可以发起网络请求的服务当作跳板来攻击其他内部服务。
攻击方式：
攻击者利用Web应用中存在的从其他服务器应用获取数据的功能，但没有对目标地址做过滤和限制。
攻击者可以构造恶意请求，使服务端向不受信任的地址发起请求，从而获取敏感信息或对内网服务进行攻击。
防范措施：
限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS请求。
限制不能访问内网IP，防止对内网进行攻击。
屏蔽或者过滤返回的详细信息，避免敏感信息泄露。
对请求地址设置白名单，只允许请求白名单内的地址。


Webpack中的Loader和Plugin在底层原理上的不同主要体现在它们的作用范围、工作方式以及与Webpack构建过程的交互方式上。

Loader的底层原理
作用范围：
Loader主要关注于模块级别的转换。它们被设计用来处理单个文件的转换过程，将文件内容从一种格式转换成Webpack能够理解的模块格式（通常是JavaScript）。
工作方式：
Loader作为Webpack的模块转换器，它们在Webpack的构建过程中被调用，接收文件内容作为输入，并输出转换后的模块内容。
Loader可以链式调用，即一个文件的转换过程可以经过多个Loader，每个Loader负责完成转换过程的一部分。
Loader的执行顺序是固定的，通常是按照配置文件中指定的顺序从右到左（或从下到上）执行。
与Webpack构建过程的交互：
Loader通过Webpack的配置文件（通常是webpack.config.js）与Webpack构建过程进行交互。
Loader的配置信息（如匹配规则、使用的Loader等）被Webpack读取并用于指导Loader的执行。
Loader的执行结果（即转换后的模块内容）被Webpack进一步处理，并最终包含在打包文件中。
Plugin的底层原理
作用范围：
Plugin则更加灵活和强大，它们可以扩展Webpack的功能，并参与到Webpack构建过程的多个阶段。
Plugin可以监听Webpack构建过程中的各种事件，并在这些事件发生时执行自定义的操作。
工作方式：
Plugin通常是一个类，它们通过实现Webpack提供的钩子（Hooks）机制来与Webpack构建过程进行交互。
在Webpack的编译过程中，当特定的事件被触发时，注册的Plugin会被调用，并执行相应的操作。
Plugin可以访问Webpack的编译对象（Compiler和Compilation），从而能够读取和修改构建过程中的各种数据。
与Webpack构建过程的交互：
Plugin的注册和配置也是通过Webpack的配置文件（webpack.config.js）完成的。
Plugin通过实现apply方法来注册自己到Webpack编译器上，并在编译器的相应事件触发时执行自定义的操作。
Plugin的执行结果可以影响Webpack构建过程的输出，如优化打包结果、生成额外的文件等。
综上所述，Loader和Plugin在底层原理上的主要区别在于它们的作用范围、工作方式以及与Webpack构建过程的交互方式。Loader专注于模块级别的转换，而Plugin则提供了更广泛和灵活的扩展能力，能够参与到Webpack构建过程的多个阶段并执行自定义操作。

Webpack的工作流程是一个复杂但有序的过程，它涉及从初始化参数到最终输出资源文件的多个步骤。在这个过程中，Loader和Plugin分别扮演着重要的角色，它们分别在不同的节点上工作，共同完成了Webpack的打包任务。

Webpack的工作流程
Webpack的工作流程大致可以分为以下几个步骤：
初始化参数：从配置文件（如webpack.config.js）和Shell语句中读取并合并参数，得出最终的配置对象。
创建Compiler对象：用上一步得到的参数初始化Compiler对象，并加载所有配置的插件。
开始编译：执行Compiler对象的run方法开始执行编译。
确定入口：根据配置中的entry找出所有的入口文件。
编译模块：从入口文件出发，调用所有配置的Loader对模块进行编译，再找出该模块依赖的模块，递归执行此步骤直到所有入口依赖的文件都经过了处理。
完成模块编译：经过Loader翻译完所有模块后，得到每个模块被翻译后的最终内容以及它们之间的依赖关系。
输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表。
输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
Loader和Plugin的节点
Loader的节点：
Loader主要负责模块的编译和转换工作。
在Webpack的编译过程中，每当Webpack处理一个模块时，它都会根据配置文件中module.rules的规则，找到对应的Loader来处理该模块。
Loader的工作发生在模块编译阶段，即上述工作流程中的“编译模块”步骤。Loader会递归地处理所有入口文件及其依赖的模块，将它们转换成Webpack能够理解的格式（通常是JavaScript）。
Plugin的节点：
Plugin是Webpack的支柱功能之一，它为Webpack提供了强大的扩展能力。
Plugin可以监听Webpack生命周期中的多个事件，并在这些事件发生时执行自定义的逻辑。
Plugin的工作节点遍布Webpack的整个工作流程，包括但不限于初始化参数、创建Compiler对象、编译模块、输出资源等各个阶段。
例如，在“输出资源”阶段，可能会有一些Plugin用于优化输出的资源文件（如压缩、添加版本号等）；在“输出完成”阶段，可能会有Plugin用于清理旧的输出文件或执行其他清理工作。
总结
Webpack的工作流程是一个有序且复杂的过程，它涉及多个步骤和组件的协同工作。Loader和Plugin作为Webpack的重要组成部分，分别在不同的节点上发挥着关键作用。Loader主要负责模块的编译和转换工作，而Plugin则提供了强大的扩展能力，允许开发者在Webpack的多个生命周期事件中插入自定义逻辑。


在Webpack中，Compiler和Compilation是两个非常重要的概念，它们在Webpack的打包过程中扮演着不同的角色。以下是它们之间的主要区别：

Compiler
定义与功能：
Compiler是Webpack的主要引擎，它控制了整个Webpack的编译流程。它是Webpack的全局单例，代表了整个Webpack从启动到关闭的生命周期。
Compiler负责读取配置、创建Compilation实例、管理插件等。它提供了丰富的钩子（hooks），允许插件在Webpack的不同阶段插入自定义逻辑。
生命周期：
Compiler的生命周期从Webpack启动开始，到Webpack关闭结束。它管理了Webpack的整个构建过程。
与插件的关系：
插件通过compiler.hooks来监听Webpack事件，从而在不同阶段插入自定义逻辑。例如，在Webpack启动前、编译前、编译后等阶段，插件都可以执行特定的任务。
Compilation
定义与功能：
Compilation代表了一次资源的构建过程。每当Webpack开始一次新的编译时，都会创建一个新的Compilation实例来管理这次编译的资源、模块、依赖等信息。
Compilation负责处理模块、生成资源、优化代码等具体的编译工作。它同样提供了丰富的钩子，允许插件在编译的不同阶段进行操作。
生命周期：
Compilation的生命周期相对较短，它只存在于一次编译过程中。每当Webpack检测到文件变化并触发新的编译时，都会创建一个新的Compilation实例。
与插件的关系：
插件可以通过监听Compilation的钩子来在编译的不同阶段执行自定义逻辑。例如，在模块构建前、构建后、优化阶段等，插件都可以对编译过程进行干预。
总结
全局与局部：Compiler是全局的，代表了Webpack的整个生命周期；而Compilation是局部的，代表了Webpack的一次编译过程。
功能与职责：Compiler负责管理和控制整个编译流程，包括读取配置、创建Compilation实例、管理插件等；而Compilation则负责具体的编译工作，如处理模块、生成资源、优化代码等。
与插件的交互：插件既可以通过监听Compiler的钩子来在Webpack的不同阶段执行自定义逻辑，也可以通过监听Compilation的钩子来在编译的不同阶段进行干预。但它们的关注点不同，Compiler的钩子更侧重于全局性的操作和设置，而Compilation的钩子则更侧重于编译过程中的具体操作和优化。
综上所述，Compiler和Compilation在Webpack中扮演着不同的角色，它们共同协作完成了Webpack的打包任务。

一、浏览器缓存概述
浏览器缓存是浏览器在请求网站资源时，将资源副本保存在本地的一种机制。当再次请求相同资源时，浏览器会根据缓存策略决定是直接使用缓存中的资源，还是向服务器发送新的请求。这样做的目的是为了减少请求次数、降低服务器压力、提升页面加载速度和用户体验。

二、缓存的分类
从宏观上看，缓存可以分为两类：私有缓存和共享缓存。但具体到浏览器缓存，我们主要关注的是私有缓存，即只能用于单独用户的缓存。

在浏览器缓存的细分上，根据缓存策略的不同，可以分为强缓存（也称为本地缓存）和协商缓存。

三、强缓存
定义：

强缓存是指只要资源在缓存有效期内，浏览器就会直接使用缓存中的资源，而不会向服务器发送请求。

实现方式：

Cache-Control：HTTP/1.1中引入的字段，用于控制资源的缓存策略。其中，max-age指令用于指定资源在缓存中的有效时间（以秒为单位）。当资源在缓存中的时间未超过max-age指定的时间时，浏览器就会直接使用缓存资源。
Expires：HTTP/1.0中引入的字段，用于指定资源的过期时间。它描述的是一个绝对时间，当浏览器时间超过这个绝对时间之后，就会重新向服务器发送请求。但由于Expires依赖于客户端的时间，存在时间篡改的风险，因此HTTP/1.1中推荐使用Cache-Control。
特点：

不会与服务器进行交互，不会发起新的请求。
强缓存分为内存缓存和硬盘缓存。内存缓存访问速度快，但关闭浏览器后会清除；硬盘缓存则可以在浏览器关闭后继续保留。
四、协商缓存
定义：

协商缓存是指浏览器在缓存资源过期后，会向服务器发送请求进行资源是否更新的验证。如果资源未更新，则服务器返回304状态码，浏览器继续使用缓存资源；如果资源已更新，则服务器返回新的资源内容。

实现方式：

Last-Modified/If-Modified-Since：浏览器第一次请求资源时，服务器会在响应头中添加Last-Modified字段，表示资源的最后修改时间。浏览器再次请求时，会在请求头中添加If-Modified-Since字段，其值为上一次请求时返回的Last-Modified值。服务器收到请求后，会比较资源的最后修改时间是否晚于If-Modified-Since指定的时间，从而决定是否返回304状态码或新的资源内容。
ETag/If-None-Match：另一种更灵活的协商缓存方式。服务器会为每个资源生成一个唯一的标识符（ETag），并在响应头中添加ETag字段。浏览器再次请求时，会在请求头中添加If-None-Match字段，其值为上一次请求时返回的ETag值。服务器收到请求后，会比较资源的当前ETag值是否与If-None-Match指定的值相同，从而决定是否返回304状态码或新的资源内容。
特点：

会与服务器进行交互，但减少了不必要的数据传输（当资源未更新时）。
适用于资源更新频率较低但又不希望频繁从服务器获取整个资源的场景。
五、缓存的好处
减少请求次数：缓存资源可以直接从本地获取，减少了向服务器发送的请求次数。
提升性能：本地资源的加载速度通常比从服务器获取要快得多。
降低服务器压力：减少了服务器的响应请求次数和数据处理量。
减少带宽消耗：缓存资源可以直接从本地获取，减少了网络数据的传输量。
六、总结
浏览器缓存是提升前端性能的重要手段之一。通过合理设置强缓存和协商缓存策略，可以有效地减少请求次数、提升页面加载速度、降低服务器压力和减少带宽消耗。在面试中，了解并掌握浏览器缓存的相关知识对于前端开发岗位来说是非常重要的。


按负载均衡策略分类
轮询（Round Robin）
原理：按顺序将请求依次分配给服务器，每个服务器按照顺序依次接收请求。
适用场景：适用于服务器性能相近的情况。
最少连接数（Least Connections）
原理：将请求分配给当前连接数最少的服务器，确保负载相对均衡。
适用场景：适用于长连接的场景。
响应时间（Response Time）
原理：将请求分配给响应时间最短的服务器，确保客户端能够获得最快的响应。
适用场景：适用于对响应时间要求较高的场景。
源IP地址哈希（Source IP Hash）
原理：根据请求的源IP地址计算哈希值，将同一IP的请求分配给同一台服务器。
适用场景：适用于需要会话保持的应用。
加权轮询（Weight Round Robin）
原理：根据服务器的权重值，按比例分配请求，权重高的服务器接收到的请求数更多。
适用场景：适用于服务器性能有差异的情况。


MVC、MVP和MVVM都是用于构建软件应用程序的设计模式，它们各自具有不同的特点和适用场景。以下是对这三种设计模式的详细讲解：

MVC（Model-View-Controller）
定义与组成：
MVC是一种将应用程序分为三个主要部分的设计模式：模型（Model）、视图（View）和控制器（Controller）。

模型（Model）：负责应用程序的数据和业务逻辑，包括数据的存储、读取、验证等操作。它是应用程序的核心组件，与视图和控制器相互独立，可以被其他应用程序重复使用。
视图（View）：负责显示用户界面，将数据呈现给用户。视图通常是根据模型中的数据生成的，可以根据需要进行定制和修改。
控制器（Controller）：负责协调和管理模型和视图之间的交互，并处理用户输入和操作。控制器接收用户的请求，更新模型和视图，将结果返回给用户。
优点：

解耦性好：MVC模式将应用程序分为三个独立的组件，使它们之间的依赖关系降到最低，提高了应用程序的可维护性和可扩展性。
可重用性好：MVC模式中的每个组件都是相对独立的，可以被其他应用程序重复使用，提高了代码的可重用性。
易于维护：MVC模式中的每个组件都具有清晰的职责和功能，使得应用程序变得易于维护。
缺点：

控制器过于臃肿：随着应用程序的复杂性增加，控制器可能会承担过多的职责，导致代码难以维护。
视图和控制器之间的耦合度高：在某些情况下，视图和控制器之间的交互可能过于紧密，增加了代码的耦合度。
应用场景：
MVC模式广泛应用于Web开发、桌面应用程序开发和移动应用程序开发等领域。例如，在Web开发中，可以使用Spring MVC框架进行Java Web开发；在桌面应用程序开发中，可以使用Java Swing框架中的MVC模式来管理Swing应用程序。

MVP（Model-View-Presenter）
定义与组成：
MVP是MVC模式的一个变体，它将MVC中的控制器角色替换为展示器（Presenter）。

模型（Model）：与MVC中的模型相同，负责应用程序的数据和业务逻辑。
视图（View）：与MVC中的视图相同，负责显示用户界面。
展示器（Presenter）：负责处理用户输入，并更新模型和视图。它作为视图和模型之间的中介，降低了视图和模型之间的耦合度。
优点：

更好的测试性和可维护性：由于视图和模型之间的解耦，使得测试和维护变得更加容易。
视图和模型之间的解耦：通过展示器的引入，降低了视图和模型之间的直接交互，提高了代码的解耦度。
缺点：

展示器可能变得过于臃肿：随着应用程序的复杂性增加，展示器可能会承担过多的职责，导致代码难以维护。
视图和展示器之间的交互可能复杂：在某些情况下，视图和展示器之间的交互可能变得复杂，增加了代码的复杂度。
应用场景：
MVP模式适用于需要更好测试性和可维护性的应用程序。在Android开发中，Google官方推荐使用MVP设计模式，并使用Android框架的基础组件（如Activity、Fragment）作为View，自行实现Presenter和Model。

MVVM（Model-View-ViewModel）
定义与组成：
MVVM是MVC的改进版，它将MVC中的控制器角色替换为视图模型（ViewModel）。

模型（Model）：与MVC和MVP中的模型相同，负责应用程序的数据和业务逻辑。
视图（View）：与MVC和MVP中的视图相同，负责显示用户界面。
视图模型（ViewModel）：负责处理视图的状态和行为，并作为视图和模型之间的中介。它封装了与视图相关的逻辑，使得视图可以更专注于显示用户界面。
优点：

视图和模型之间的解耦：通过视图模型的引入，实现了视图和模型之间的完全解耦，使得代码的维护变得更加容易。
更好的可重用性：视图模型中的逻辑可以被多个视图重用，提高了代码的可重用性。
易于测试：由于视图和模型之间的解耦，使得测试变得更加容易。
缺点：

可能引入过多的逻辑到视图模型中：随着应用程序的复杂性增加，视图模型可能会变得过于臃肿，包含过多的业务逻辑。
学习曲线较陡：MVVM模式相对于MVC和MVP来说更为复杂，需要开发人员花费更多的时间来学习和掌握。
应用场景：
MVVM模式适用于需要大量数据绑定和复杂交互的应用程序，例如大型单页Web应用程序和移动应用程序。流行的前端框架如AngularJS、Angular、Vue.js和React.js等都提供了MVVM设计模式的支持。


算法