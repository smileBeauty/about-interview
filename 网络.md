## 网络

#### CDN 原理

用户在首次访问一个 url 获取资源的时候会经历以下过程

- 浏览器先检查本地缓存
- 对域名进行 DNS 查询，得到一个 CNAME 记录
- 在对 CNAME 进行 DNS 查询，得到一个 A/AAAA 记录 IP 地址（给出了离用户最近的边缘节点）
- 边缘服务器检查自己的缓存是否有该资源
- 向中心服务器发出请求获取资源
- 向源站发起请求获取资源

#### CDN 获取最近节点资源的算法是什么

应该是 ：迪积斯特拉（Dijkstra）算法？ 图的最短路径算法  
迪积斯特拉算法会生成一颗最短路径树，树的根为起点 s,树的分支是从顶点 s 到图 G 中所有其他顶点的最短路径。  
从根本上来说迪积斯特拉算法,通过选择一个顶点，并不断探索与此顶点相关的边，以此来确定每个顶点的最短路径是否为最优。

#### https 握手机制

1.客户端向服务端发送 Client Hello 消息，包含客户端生成的随机数 Random1,客户端支持的加密算法和 ssl version 2.服务端想客户端发送 serverHello 消息，包含随机数 random2，以及服务端从客户端支持的加密算法中选择的加密算法以及 ssl 版本 3.然后服务端将证书下发给客户端，证书中包含服务端的公钥。 4.客户端验证证书，验证之后取出公钥并生成随机数 random3,使用公钥进行非对称加密 random3,生成 pre-master-key,
然后将 pre-master-key 发送给服务端 5.服务端使用自己的私钥解出 random3，在使用之前协商好的加密算法加密 random123,至此生成了一套密钥，用于之后消息的加密，
服务端发送公钥加密的之前消息的 hash 值给客户端，用于提供给客户端验证。 6.客户端通知服务端之后的消息使用协商的密钥
7.client-Finish 客户端发送第一条加密的消息，服务端收到后使用私钥解密 8.服务端通知客户端之后的消息都是用私钥加密
9.server-finish 服务端发送第一条加密信息

#### _**TCP 协议三次握手**_

TCP 只能由客户端向服务端发起

- 客户端给服务端发送一个带 syn 标志的报文（表示发起连接）
- 服务端给客户端发送一个带有 syn 和 ack 的报文（回复以及发起连接）
- 客户端在发送给服务端一个 ack 报文（回复）

#### _**TCP 协议四次挥手**_

因为 TCP 是全双工，因此每个方向必须单独关闭

- 客户端发送 FIN，用来关闭客户端到服务端的数据传送
- 服务端发送 ack,确认序号为收到的序号加一
- 服务端关闭客户端的连接，向客户端发送 FIN 终止到客户端的数据传送
- 客户端回复 ACK 报文用来确认关闭

#### _**为什么是链接需要三次而断开需要四次**_

三次握手的目的是为了防止已失效的连接请求报文段突然又发送到了服务端因此而产生错误
四次挥手的是因为，TCP 是全双工的协议，每个方向必须单独关闭，而之所以没有将第二次第三次合并，是因为在
一端想终止连接时，并不确定另一端的数据是否已经传输完毕，所以需要先发送 ACK 报文

#### _**GET 和 POST 的区别**_

get 请求应该是幂等的 普遍来说 GET 只是用了 http 协议的 method url header 但是 body 也可以用在 GET 中，可缓存
post 请求一般都是带有副作用的，使用请求体 body 向服务端传递一些信息，不可缓存
在安全性上来说，get 和 post 所传递的信息都是明文传递，区别在于 get 传递的信息一般都可以在 url 中看见，而 post 的信息都在 body 中，
但并非 get 请求不能使用 body 来传递信息，elasticsearch 中的 GET 就使用了 body 来传递查询信息，post 也可以实现成无副作用的
关于编码，也并非是 get 与 post 的区别 而是 url 和 body 编码的不同，url 的编码在地址栏可以明文传递的只有 ASCII 的一部分，但一些编码是可以经过
encode 之后再 url 中传递的，而 body 是可以在 http 的请求头中来指定编码
关于 post 两次请求的问题，同样也是优化的问题，post 既可以一次将请求头和请求体都传递过去，也可以分两次来传递请求头和请求体。
